module AuctionDemo;

//import * from Absstdlib;
//import Functions from Absstdlib;

type Price = Rat;

data Route = ARoute(Rat departure, Maybe<Destination> city)| NoRoute;
data Goal = AGoal(Rat availableSince, Rat deadline, Maybe<Destination> dest)| NoGoal;
data Destination = ADestination(String name, Rat driveTime, Rat costToD)| NoDest;
data Train = ATrain(Int space, Rat startAvailable, Rat endAvailable, Rat budget, Rat riskFactor);
data Container = AContainer(Destination endPoint, Rat startAv, Rat d, Rat b, Rat rf);
type Belief = Price; // Budget for biddingagent = its belief base
type BeliefBase = Map<Route, Price>; // bb for auctioneeragent
//type GoalBase = List<Goal>;

data Message = 
  Announce(Agent announceCaller, Route toSell, Price price) | 
  Bid(Agent bidCaller, Route toBuy, Price bid) |
  Sold(Agent soldCaller, Route soldItem) |
  Result(List<Agent> winners, List<Price> prices, List<Agent> unhappy);
  
// a number that says how much the bidder is interested: if the bidder has time then it bids less
// RESULT RANGE: (0,1] , 1 most interested    
def Rat strictFit(Goal g, Route r) = 
    case g {
	AGoal(arrival, deadline, goalDest) => case r {
	    ARoute(time, dest) =>
            if (time > deadline) then
	    -1
	    else
	    case dest{
		Just(d)=>
		case goalDest{
		    Just(gd) => if(d==gd &&  (arrival <= time) ) then (time - arrival + 1) / (deadline - arrival + 1)
		    else 0;
		    Nothing => if(arrival <= time ) then (time - arrival + 1) / (deadline - arrival + 1)
		    else 0;
		};
		Nothing => if(arrival <= time ) then (time - arrival + 1) / (deadline - arrival + 1)
		    else 0;
	    };
	};
    };

// risk and timeFit must be between 0..1 so that bid stays between min and budget
// risk is a parameter of every bidderagent given by DSOL
def Price bidStrategy(Price min, Price budget, Rat timeFit, Rat risk) =
    if (budget < min) then
        0
    else if (timeFit <= 0) then
        timeFit                // means either not interested or unhappy
    else
	min + (budget - min) * timeFit * risk;

interface Agent {
    Unit message(Message m);
}


interface AuctionOrganizer extends Agent {
    // TODO: create trains and containers agents
    //Unit init();
    // organize two auctions by creating 
    Unit start(Rat timeSlot);
}

class AuctionOrganizerAgent (List<Train> trains, List<Container> containers) implements AuctionOrganizer {
    List<Agent> trainAgents= Nil;
    List<Agent> containerAgents= Nil;
    Int round = 0;
    Rat timeSlot = 0;
    
    BeliefBase itemValues = EmptyMap;
    List<Route> init_goals = Nil;
    List<Agent> bidderList = Nil;
    Map<Route, Pair<Agent, Price>> winners = EmptyMap;

    Int numWinners =0;
	
	
	Unit goal_rule(Route g) {
	   println("Starting an auction.");
	   Maybe<Price> maybe = lookup(this.itemValues, g);
	   Price p = case maybe {
	   Just(value) =>  value;
	   Nothing =>  0; 	// if no value is known, we sell it for any price
	   };
	   println("AA: inform all bidders");
	   Int i = 0;
	   while (i<length(this.trains)) {
	       Train nA = nth(this.trains,i);
	       this.message(Announce(this, g, p));
	       i=i+1;
	   }
	   println("All informed. Now waiting");
	   
		
		Maybe<Pair<Agent, Price>> mValue = lookup(this.winners, g);
              case mValue {
		  Just(Pair(winningAgent, price)) => {
		      
			  if (winningAgent == null) {
			      println("No winner!");
			      // should we reduce the expected price? Anyway, with the current bidding strategy, it has no effect
			  } else {
			      println("Sold for the price of: ");
			      Message argm = Sold(this,g);
			      this.message(argm);
			      this.init_goals = without(this.init_goals, g); // will add again if not sold?
			      // TODO: inform organizer (list of winners and list of unhappy)
			      List<Agent> lw = Cons(winningAgent, Nil);
			      List<Price> lp = Cons(price, Nil);
			      List<Agent> lu = Nil;
			      Message argr  = Result(lw, lp, lu);
			      this.message(argr);
			  }
		      
		      }
		      Nothing => { println("What?"); }
		  }
   }
	
    Unit start(Rat timeSlot){
	    // new AuctioneerAgent (for the 1 train)
	    this.round=1;
	    this.timeSlot = timeSlot;
	    Route freeRoute = ARoute(timeSlot, Nothing);
	    this.init_goals=Cons(freeRoute, this.init_goals);
	    this.itemValues=put(this.itemValues, freeRoute, 0);
	    this.bidderList = this.trainAgents; 
	    this.run();
	    // await for the auction results

        // new AuctioneerAgent (for the containers)

        // await

        // send it to DSOL through done
    }
    
     Unit message(Message m) {
		case m {
			Result(w, p, u) => {
				if(this.round==1){
					this.round1(w, p, u);
				}
			}
			Announce(caller, slot, price) =>  {
		    	Int noContainers =0;
		    	//List<Container> containers = Nil;
		    	while(noContainers<100){
				    Destination duisburg  = ADestination("Duisburg", 4, 4000);
					Destination munich  = ADestination("Munich", 16, 16000);
				    Destination dest = NoDest; 
				    if (random(10) > 7){ 
				    	dest=duisburg;
				    } 
				    else{
				     dest= munich;
				     }
				    Rat startTime  = 0;
				    if (random(10) > 7){
				    	startTime=1;
				    }
				    else {
						startTime=3;				    
				    }
					Rat riskFactor  = random(10);
					riskFactor = riskFactor/100;
					Rat budget = 100 * random(10) + 100;
					if(dest == munich){
						budget = budget*4;
						}
					Rat latest = case dest {
										ADestination(_,y,_) =>
											startTime + 4 + y;
									};
					Container c = AContainer(dest, startTime, latest, budget, riskFactor);
					//containers=appendright(containers, c);	
					noContainers = noContainers + 1;
				}
		    	
				//println("B: Received announce");
				Price budget = belief;
				if (length(goals)>0) {
					Goal goal = nth(goals, 0);   // we have only one goal, we assume for now it's only 1 and same
					Rat timeFit = strictFit(goal, slot);
					Price myOffer = bidStrategy(price, budget, timeFit, risk);
					//println("B: Sending myBid ");
					//println(myOffer);
					if (myOffer < 0) {
					    goals = Nil;   // unhappy
					} 
					else{ 
						if (myOffer >= 0) {   // zero bid == not interested
						    //println("B: Sending myBid ");
							//println(myOffer);
						    Message bidOffer = Bid(this, slot, myOffer);
						    Fut<Unit> f = caller ! message(bidOffer);
						    await f?;  // alternative: return the bid value
						}	
					}
				}
		    }
		    Sold(caller, slot) => {
				println("B: I won the auction "); 
				goals = Nil;
		    }
		    
		    Bid(caller, slot, price) =>  {
              //println("AA: Received a bid.");
              //println(price);
              Maybe<Pair<Agent, Price>> mValue = lookup(winners, slot);
              case mValue {
	              Just(APair(topAgent, topPrice)) => {
			              // TODO: keep track of unhappy agents (returned -1) in a list and return it to AuctonOrganizer.done()
			              // TODO: keep a list of winners and their bids (+ 1 spot) because there are multiple winners
	                      if (price > topPrice) {	// if equal we favor the first bid 
				  			winners = put(winners, slot, APair(caller, price));	// replace with the new top bid
	          			  }
			  	  }
				  Nothing => {
				      Price min = case lookup(this.beliefs, slot) {
									  Just(value) =>  value;
									  Nothing =>  0; 	// if no value is known, we sell it for any price 
								  };
				      if (price >= min) {
				      	winners = put(winners, slot, APair(caller, price));
				      } // first bid
				  }
	      	  }
	  	  }
		    _ => { println("Unexpected message."); }
		}
	 }
	 
	 Unit round1(List<Agent> winners, List<Price> prices, List<Agent> unhappy){
	     Int l = winners.size();
	     if(l == 0){
	 	 println("No Train available");	
	     }
	     else{
	 	 Price p = prices.geT(0);
	 	 println("Winner is paying");
	 	 println (p);
	 	 Route freeRoute = ARoute(this.timeSlot, None);
	    	 List<Route> goals = new LinkedList();
	    	 goals.add(freeRoute);
	    	 Map<Route, Price> beliefBase = new HashMap();
	         beliefBase.put(freeRoute, 0);
	    	 Agent trainAuc = new AuctioneerAgent(beliefBase, goals, this.containerAgents, 30, this);
	     }
	 }
	 
	 Unit run() {
    	println("AA: Auctioneer started.");
      	Int i = length(this.init_goals) - 1;
	    while (i >= 0) {
	       Route nA = nth(this.init_goals, i);
	       this.goal_rule(nA);
	       i=i-1;
	    }
  	}
}



{
	println("M: begin");
	Destination duisburg  = ADestination("Duisburg", 4, 4000);
	Destination munich  = ADestination("Munich", 16, 16000);
	List<Train> trains  = Nil;
	List<Container> containers = Nil;
	Int noTrains = 10;
	Int noContainers = 1000;
	
	while(noTrains>0){
		Int startTime  = random(3);
		Rat riskFactor  = random(10);
		riskFactor = riskFactor/100;
		Rat budget = 10000 * random(10) + 1000;
		Int endTime = startTime + 4;
		Train tr = ATrain(30, startTime, endTime, budget, riskFactor);
		trains= Cons(tr,trains);	
		noTrains = noTrains -1;
	}
	
	println("M:Init Trains complete");
	
	while(noContainers>0){
	    Destination dest = if random(10) > 7 then duisburg else munich;
	    Rat startTime  = if random(10) > 7 then 1 else 3;
		Rat riskFactor  = random(10);
		riskFactor = riskFactor/100;
		Rat budget = 100 * random(10) + 100;
		if(dest == munich)
			budget = budget*4;
		Rat latest = case dest {
							ADestination(_,y,_) =>
								startTime + 4 + y;
						};
		Container c = AContainer(dest, startTime, latest, budget, riskFactor);
		containers=Cons(c, containers);	
		noContainers = noContainers - 1;
	}  
	
	AuctionOrganizer pr = new AuctionOrganizerAgent(trains, containers);
	//pr!init();
	pr!start(1);
	println("M: end");


}