module AuctionDemo;

import * from Java.Util;
import Option from Scala;
import Map from Java.Util;
import AbstractMap from Java.Util;
import Map.Entry from Java.Util;
import AbstractMap.SimpleEntry from Java.Util;

type Price = Rat;

data Route = ARoute(Rat departure, Option<Destination> city)| NoRoute;
data Goal = AGoal(Rat availableSince, Rat deadline, Option<Destination> dest)| NoGoal;
data Destination = ADestination(String name, Rat driveTime, Rat costToD)| NoDest;
data Train = ATrain(Int space, Rat startAvailable, Rat endAvailable, Rat budget, Rat riskFactor);
data Container = AContainer(Destination endPoint, Rat startAvailable, Rat deadline, Rat budget, Rat riskFactor);
type Belief = Price; // Budget for biddingagent = its belief base
type BeliefBase = Map<Route, Price>; // bb for auctioneeragent
//type GoalBase = List<Goal>;


// ["JavaExternClass":"nl.prorail.soft.simulation.Destination"]
//interface Destination {
  //  String getName();
    //Rat getDrivingTimeFromRtm();
   // Rat getCostToDriveToDestination();
//}

 
// interface or data type?
interface BiddingInfo{
    String getId();
    Goal getGoal();
    Price getBudget();
    Rat getArrivalTime();
    Rat getDeadline();
    Unit setPaidPrice(Price price);
    Price getPaidPrice();
    AuctioneerInfo asAuctioneer();   // a bidding agent can become an auctioneer (for trains) -- container returns null
}

interface AuctioneerInfo{
    Int getNumberOfWinners();
}

data Message = 
  Announce(Agent announceCaller, Route toSell, Price price) | 
  Bid(Agent bidCaller, Route toBuy, Price bid) |
  Sold(Agent soldCaller, Route soldItem) |
  Result(List<Agent> winners, List<Price> prices, List<Agent> unhappy);


// a number that says how much the bidder is interested: if the bidder has time then it bids less
// RESULT RANGE: (0,1] , 1 most interested    
def Rat strictFit(Goal g, Route r) = 
    case g {
	AGoal(arrival, deadline, goalDest) => case r {
	    ARoute(time, dest) =>
            if (time > deadline) then
	    -1
	    else
	    case dest{
		Some(d)=>
		case goalDest{
		    Some(gd) => if(d==gd &&  (arrival <= time) ) then (time - arrival + 1) / (deadline - arrival + 1)
		    else 0;
		    None => if(arrival <= time ) then (time - arrival + 1) / (deadline - arrival + 1)
		    else 0;
		};
		None => if(arrival <= time ) then (time - arrival + 1) / (deadline - arrival + 1)
		    else 0;
	    };
	};
    };

// risk and timeFit must be between 0..1 so that bid stays between min and budget
// risk is a parameter of every bidderagent given by DSOL
def Price bidStrategy(Price min, Price budget, Rat timeFit, Rat risk) =
    if (budget < min) then
        0
    else if (timeFit <= 0) then
        timeFit                // means either not interested or unhappy
    else
	min + (budget - min) * timeFit * risk;

interface Agent {
    Unit message(Message m);
}

interface AuctionOrganizer extends Agent {
    // TODO: create trains and containers agents
    //Unit init();
    // organize two auctions by creating 
    Unit start(Rat timeSlot);
}

class AuctionOrganizerAgent (List<Train> trains, List<Container> containers) implements AuctionOrganizer {
    List<Agent> trainAgents;
	List<Agent> containerAgents;
    Int round = 0;
    Rat timeSlot = 0;
    
    {
	trainAgents = new LinkedList();
	containerAgents = new LinkedList();
	Int i = 0;
	Int l = this.trains.size();
	Int lc = this.containers.size();
		while(i< l){
			Train t = this.trains.geT(i);
			case t{
				ATrain(s, sa, ea, b, r) => {
					Goal g= AGoal(sa,ea, None);
					Agent ba = new BiddingAgent(b, g, r);
					this.trainAgents.add(ba);
				}
			}
			i = i+1;
		}
		i=0;
		while(i< lc){
		    Container c = this.containers.geT(i);
		    case c{
			AContainer(dest, sa, d, b, r) => {
			    Goal g= AGoal(sa,d, Some(dest));
			    Agent ba = new BiddingAgent(b, g, r);
			    this.containerAgents.add(ba);
			}
		    }
		    i = i+1;
		}
	}
	
    Unit start(Rat timeSlot){
	    // new AuctioneerAgent (for the 1 train)
	    this.round=1;
	    this.timeSlot = timeSlot;
	    Route freeRoute = ARoute(timeSlot, None);
	    List<Route> goals = new LinkedList();
	    goals.add(freeRoute);
	    Map<Route, Price> beliefBase = new HashMap();
	    beliefBase.put(freeRoute, 0);
	    Agent trainAuc = new AuctioneerAgent(beliefBase, goals, this.trainAgents, 1, this);
	    // await for the auction results

        // new AuctioneerAgent (for the containers)

        // await

        // send it to DSOL through done
    }
    
     Unit message(Message m) {
		case m {
			Result(w, p, u) => {
				if(this.round==1){
					this.round1(w, p, u);
				}
			}
		}
	 }
	 
	 Unit round1(List<Agent> winners, List<Price> prices, List<Agent> unhappy){
	     Int l = winners.size();
	     if(l == 0){
	 	 println("No Train available");	
	     }
	     else{
	 	 Price p = prices.geT(0);
	 	 println("Winner is paying");
	 	 println (p);
	 	 Route freeRoute = ARoute(this.timeSlot, None);
	    	 List<Route> goals = new LinkedList();
	    	 goals.add(freeRoute);
	    	 Map<Route, Price> beliefBase = new HashMap();
	         beliefBase.put(freeRoute, 0);
	    	 Agent trainAuc = new AuctioneerAgent(beliefBase, goals, this.containerAgents, 30, this);
	     }
	 }
}

interface DSOL {
    Unit done(Rat timeSlot, Destination dest, AuctioneerInfo tr, List<BiddingInfo> winnerContainers, List<BiddingInfo> unhappyTrains, List<BiddingInfo> unhappyContainers);
}


// init_value and init_gaol must be about the same route, 

// TODO: each biddingagent has to have a comparable unique identifier for reproducibility
class BiddingAgent(Belief belief, Goal init_goal, Rat risk) implements Agent {
    List<Goal> goals;
    {
	goals = new LinkedList();
	this.goals.add(init_goal);
	}
    Unit message(Message m) {
		case m {
		    Announce(caller, slot, price) =>  {
				println("B: Received announce");
				Price budget = belief;
				Int l = goals.size(); 
				if (l>0) {
					Goal goal = goals.geT(0);   // we have only one goal, we assume for now it's only 1 and same
					Rat timeFit = strictFit(goal, slot);
					Price myOffer = bidStrategy(price, budget, timeFit, risk);
					println("B: Sending myBid ");
					println(myOffer);
					if (myOffer < 0) {
					    goals.clear();   // unhappy
					} 
					else{ 
						if (myOffer >= 0) {   // zero bid == not interested
						    println("B: Sending myBid ");
							println(myOffer);
						    Message bidOffer = Bid(this, slot, myOffer);
						    Fut<Unit> f = caller ! message(bidOffer);
						    await f?;  // alternative: return the bid value
						}	
					}
				}
		    }
		    Sold(caller, slot) => {
				println("B: I won the auction "); 
				goals.clear();
		    }
		    _ => { println("Unexpected message."); }
		}
    }
}

class AuctioneerAgent(BeliefBase itemValues, List<Route> init_goals, List<Agent> bidderList, Int numWinners, Agent organizer) implements Agent {
   BeliefBase beliefs = itemValues;	// what I think items are worth
   List<Route> goals = init_goals;
   
   Map<Route, Entry<Agent, Price>> winners;
   
   {
       winners = new HashMap(); 
   this!run();
   }
   
   Unit message(Message m) {
       case m { 
          Bid(caller, slot, price) =>  {
              println("AA: Received a bid.");
              println(price);
              Entry<Agent, Price> mValue = winners.geT(slot);

	      if(mValue != null){
		  Agent topAgent = mValue.getKey();
		  Price topPrice = mValue.getValue();
		  if (price > topPrice) {	// if equal we favor the first bid
		      Entry<Agent, Price> top = new SimpleEntry(caller, price);
		      winners.put(slot, top);	// replace with the new top bid
		  }
	      }
	      else{
		  Price minimum = this.beliefs.geT(slot); 
		  Price min = if(minimum == null) then 0  else minimum;
		  if (price > min) {	// if equal we favor the first bid
		      Entry<Agent, Price> top = new SimpleEntry(caller, price);
		      winners.put(slot, top);	// replace with the new top bid
		  }
	      }
	  }
          _ => { 
          			println("Unexpected message."); 
          }
      }
   }
   
   Unit goal_rule(Route g) {
	   println("Starting an auction.");
	   Price option = this.beliefs.geT(g);
	   Price p = if(option==null) then 0 else option;
	   println("AA: inform all bidders");
	   List<Agent> iBidder = bidderList;
	   List<Fut<Unit>> toBid = new LinkedList();
	   Int i = 0;
	   Int l = iBidder.size(); 
	   while (i< l ) {
	       Agent nA = iBidder.geT(i);
	       i=i+1;
	       Fut<Unit> f = nA ! message(Announce(this, g, p));
	       toBid.add(f);
	   }
	   println("All informed. Now waiting");
	   // can I await for all futures in one go?
	   i=0;
	   l= toBid.size();
	   while(i< l){
			Fut<Unit> f = toBid.geT(i);
			await f?;
			i = i+1;
			println(i);
	   }
     
     
	// TODO: Bids are sent, but Option not yet processed?
	   println("Now all bids are received ");
	// TODO: match from winners list winner(i) with bid(winner(i+1))
	
	   Entry<Agent, Price> mValue = winners.geT(g);
	   if(mValue!=null){
	       Agent winningAgent = mValue.getKey();
	       Price price = mValue.getValue();
	       if (winningAgent == null) {
		   println("No winner!");
		   // should we reduce the expected price? Anyway, with the current bidding strategy, it has no effect
	       }
	       else {
		   println("Sold for the price of: ");
		   println(price);
		   Message argm = Sold(this,g);
		   winningAgent ! message(argm);
		   this.goals.remove(g); // will add again if not sold?
		   // TODO: inform organizer (list of winners and list of unhappy)
	       }
	   }
	   else{
	       println("What?");
	   }
       }
   
   
  Unit run() {
    println("AA: Auctioneer started.");
    //while(this.goals != EmptySet) {
      // in Haskell: mapM(goal_rule, this.goals);
      // in plain ABS
      List<Route> iGoals = this.goals;
      List<Fut<Unit>> goalFutures = new LinkedList();
      Int i = iGoals.size();
      i=i- 1;
      while (i >= 0) {
       Route nA = iGoals.geT(i);
       Fut<Unit> f = this ! goal_rule(nA);
       goalFutures. add(f);
       i=i-1;
      }
      println("Auctioneer finished the goals!");
      i = 0;
      Int l = goalFutures.size();
      while (i< l) {
        Fut<Unit> f= goalFutures.geT(i);
        await f?;
        i = i + 1;
      }
    //}
  }
}

{
	println("M: begin");
	Destination duisburg  = ADestination("Duisburg", 4, 4000);
	Destination munich  = ADestination("Munich", 16, 16000);
	List<Train> trains  = new LinkedList();
	List<Container> containers = new LinkedList();
	Int noTrains = 10;
	Int noContainers = 1000;
	Random r = new Random();

	while(noTrains>0){
		Int startTime  = r.nextInt(3);
		Rat riskFactor  = r.nextFloat();
		Rat bf = r.nextFloat();
		Rat budget = 100000 * bf + 1000;
		Int endTime = startTime + 4;
		Train tr = ATrain(30, startTime, endTime, budget, riskFactor);
		trains.add(tr);	
		noTrains = noTrains -1;
	}
	
	println("M:Init Trains complete");
	
	while(noContainers>0){
	    Int df = r.nextInt(10);
	    Destination dest = if df > 7 then duisburg else munich;
	    df = r.nextInt(10);
	    Rat startTime  = if df > 7 then 1 else 3;
		Rat riskFactor  = r.nextFloat();
		Rat bf = r.nextFloat();
		Rat budget = 1000 * bf + 100;
		if(dest == munich)
			budget = budget*4;
		Rat latest = case dest {
		    ADestination(_,y,_) =>
		    startTime + 4 + y;
		};
		Container c = AContainer(dest, startTime, latest, budget, riskFactor);
		containers.add(c);	
		noContainers = noContainers - 1;
	}  
	
	AuctionOrganizer pr = new AuctionOrganizerAgent(trains, containers);
	//pr!init();
	pr!start(1);
	println("M: end");


}
