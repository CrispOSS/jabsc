module AuctionDemo;

import * from Absstdlib;
import * from Absstdlib.Functions;

type Price = Rat;

data Route = ARoute(Rat departure, Maybe<Destination> city)| NoRoute;
data Goal = AGoal(Rat availableSince, Rat deadline, Maybe<Destination> dest)| NoGoal;
data Destination = ADestination(String name, Rat driveTime, Rat costToD)| NoDest;
data Train = ATrain(Int space, Rat startAvailable, Rat endAvailable, Rat budget, Rat riskFactor);
data Container = AContainer(Destination endPoint, Rat startAvailable, Rat deadline, Rat budget, Rat riskFactor);
type Belief = Price; // Budget for biddingagent = its belief base
type BeliefBase = Map<Route, Price>; // bb for auctioneeragent
//type GoalBase = List<Goal>;


// ["JavaExternClass":"nl.prorail.soft.simulation.Destination"]
//interface Destination {
  //  String getName();
    //Rat getDrivingTimeFromRtm();
   // Rat getCostToDriveToDestination();
//}


// interface or data type?
interface BiddingInfo{
    String getId();
    Goal getGoal();
    Price getBudget();
    Rat getArrivalTime();
    Rat getDeadline();
    Unit setPaidPrice(Price price);
    Price getPaidPrice();
    AuctioneerInfo asAuctioneer();   // a bidding agent can become an auctioneer (for trains) -- container returns null
}

interface AuctioneerInfo{
    Int getNumberOfWinners();
}

data Message = 
  Announce(Agent announceCaller, Route toSell, Price price) | 
  Bid(Agent bidCaller, Route toBuy, Price bid) |
  Sold(Agent soldCaller, Route soldItem) |
  Result(List<Agent> winners, List<Price> prices, List<Agent> unhappy);


// a number that says how much the bidder is interested: if the bidder has time then it bids less
// RESULT RANGE: (0,1] , 1 most interested    
def Rat strictFit(Goal g, Route r) = 
    case g {
	AGoal(arrival, deadline, goalDest) => case r {
	    ARoute(time, dest) =>
            if (time > deadline) then
	        -1
            else if ((dest == goalDest || ( (isJust(dest))) || ( (isJust(goalDest)))) && (arrival <= time)) then
	        (time - arrival + 1) / (deadline - arrival + 1)   // deadline missed == no point in going anymore
	    else
	        0;
	};
    };

// risk and timeFit must be between 0..1 so that bid stays between min and budget
// risk is a parameter of every bidderagent given by DSOL
def Price bidStrategy(Price min, Price budget, Rat timeFit, Rat risk) =
    if (budget < min) then
        0
    else if (timeFit <= 0) then
        timeFit                // means either not interested or unhappy
    else
	min + (budget - min) * timeFit * risk;

interface Agent {
    Unit message(Message m);
}

interface AuctionOrganizer extends Agent {
    // TODO: create trains and containers agents
    //Unit init();
    // organize two auctions by creating 
    Unit start(Rat timeSlot);
}

class AuctionOrganizerAgent (List<Train> trains, List<Container> containers) implements AuctionOrganizer {
    List<Agent> trainAgents = Nil;
	List<Agent> containerAgents = Nil;
    Int round = 0;
    Rat timeSlot = 0.0;
    
    {
		Int i = 0;
		
		while(i< length(this.trains)){
			Train t = nth(this.trains, i);
			case t{
				ATrain(s, sa, ea, b, r) => {
					Goal g= AGoal(sa,ea, Nothing);
					Agent ba = new BiddingAgent(b, g, r);
					appendright(this.trainAgents, ba);
				}
			}
			i = i+1;
		}
		
		i=0;
		while(i< length(this.containers)){
			Container c = nth(this.containers, i);
			case c{
				AContainer(dest, sa, d, b, r) => {
					Goal g= AGoal(sa,d, Just(dest));
					Agent ba = new BiddingAgent(b, g, r);
					appendright(this.containerAgents, ba);
				}
			}
			i = i+1;
		}
		
	}
	
    Unit start(Rat timeSlot){
	    // new AuctioneerAgent (for the 1 train)
	    this.round=1;
	    this.timeSlot = timeSlot;
	    Route freeRoute = ARoute(timeSlot, Nothing);
	    List<Route> goals = Nil;
	    appendright(goals, freeRoute);
	    Map<Route, Price> beliefBase = EmptyMap;
	    put(beliefBase, freeRoute, 0.0);
	    Agent trainAuc = new AuctioneerAgent(beliefBase, goals, this.trainAgents, 1, this);
	    // await for the auction results

        // new AuctioneerAgent (for the containers)

        // await

        // send it to DSOL through done
    }
    
     Unit message(Message m) {
		case m {
			Result(w, p, u) => {
				if(this.round==1){
					this.round1(w, p, u);
				}
			}
		}
	 }
	 
	 Unit round1(List<Agent> winners, List<Price> prices, List<Agent> unhappy){
	 	if(length(winners) == 0){
	 		println("No Train available");	
	 	}
	 	
	 	else{
	 		Price p = nth(prices, 0);
	 		println("Winner is paying");
	 		println (p);
	 		Route freeRoute = ARoute(this.timeSlot, Nothing);
	    	List<Route> goals = Nil;
	    	appendright(goals, freeRoute);
	    	Map<Route, Price> beliefBase = EmptyMap;
	    	put(beliefBase, freeRoute, 0.0);
	    	Agent trainAuc = new AuctioneerAgent(beliefBase, goals, this.containerAgents, 30, this);
	    	
	 	}
	 }
    
    
}

interface DSOL {
    Unit done(Rat timeSlot, Destination dest, AuctioneerInfo tr, List<BiddingInfo> winnerContainers, List<BiddingInfo> unhappyTrains, List<BiddingInfo> unhappyContainers);
}


// init_value and init_gaol must be about the same route, 

// TODO: each biddingagent has to have a comparable unique identifier for reproducibility
class BiddingAgent(Belief belief, Goal init_goal, Rat risk) implements Agent {
    List<Goal> goals = Nil;
    {
     	appendright(this.goals,init_goal);
	}
    Unit message(Message m) {
		case m {
		    Announce(caller, slot, price) =>  {
				println("B: Received announce");
				Price budget = belief;
				if (length(goals)>0) {
					Goal goal = nth(goals, 0);   // we have only one goal, we assume for now it's only 1 and same
					Rat timeFit = strictFit(goal, slot);
					Price myOffer = bidStrategy(price, budget, timeFit, risk);
					println("B: Sending myBid ");
					println(myOffer);
					if (myOffer < 0) {
					    goals = Nil;   // unhappy
					} 
					else{ 
						if (myOffer >= 0) {   // zero bid == not interested
						    println("B: Sending myBid ");
							println(myOffer);
						    Message bidOffer = Bid(this, slot, myOffer);
						    Fut<Unit> f = caller ! message(bidOffer);
						    await f?;  // alternative: return the bid value
						}	
					}
				}
		    }
		    Sold(caller, slot) => {
				println("B: I won the auction "); 
				goals = Nil;
		    }
		    _ => { println("Unexpected message."); }
		}
    }
}

class AuctioneerAgent(BeliefBase itemValues, List<Route> init_goals, List<Agent> bidderList, Int numWinners, Agent organizer) implements Agent {
   BeliefBase beliefs = itemValues;	// what I think items are worth
   List<Route> goals = init_goals;
   
   Map<Route, Pair<Agent, Price>> winners = EmptyMap();
   
   {
   this!run();
   }
   
   Unit message(Message m) {
       case m { 
          Bid(caller, slot, price) =>  {
              println("AA: Received a bid.");
              println(price);
              Maybe<Pair<Agent, Price>> mValue = lookup(winners, slot);
              case mValue {
	              Just(APair(topAgent, topPrice)) => {
			              // TODO: keep track of unhappy agents (returned -1) in a list and return it to AuctonOrganizer.done()
			              // TODO: keep a list of winners and their bids (+ 1 spot) because there are multiple winners
	                      if (price > topPrice) {	// if equal we favor the first bid 
				  			winners = put(winners, slot, APair(caller, price));	// replace with the new top bid
	          			  }
			  	  }
				  Nothing => {
				      Price min = case lookup(this.beliefs, slot) {
									  Just(value) =>  value;
									  Nothing =>  0; 	// if no value is known, we sell it for any price 
								  };
				      if (price >= min) {
				      	winners = put(winners, slot, APair(caller, price));
				      } // first bid
				  }
	      	  }
	  	  }
          _ => { 
          			println("Unexpected message."); 
          }
      }
   }
   
   Unit goal_rule(Route g) {
	   println("Starting an auction.");
	   Maybe<Price> maybe = lookup(this.beliefs, g);
	   Price p = case maybe {
	   Just(value) =>  value;
	   Nothing =>  0; 	// if no value is known, we sell it for any price
	   };
	   println("AA: inform all bidders");
	   List<Agent> iBidder = bidderList;
	   List<Fut<Unit>> toBid = Nil;
	   Int i = 0;
	   while (i<length(iBidder)) {
	       Agent nA = nth(iBidder,i);
	       i=i+1;
		   Fut<Unit> f = nA ! message(Announce(this, g, p));
		   toBid = Cons(f, toBid);
	   }
	   println("All informed. Now waiting");
	   println(length(toBid));
	   // can I await for all futures in one go?
	   i=0;
	   while(i< length(toBid)){
			Fut<Unit> f = nth(toBid, i);
			await f?;
			i = i+1;
			println(i);
	   }
     
     
  		// TODO: Bids are sent, but maybe not yet processed?
		println("Now all bids are received ");
		// TODO: match from winners list winner(i) with bid(winner(i+1))
		
		Maybe<Pair<Agent, Price>> mValue = lookup(winners, g);
              case mValue {
       Just(APair(winningAgent, price)) => {
         {if (winningAgent == null) {
           println("No winner!");
           // should we reduce the expected price? Anyway, with the current bidding strategy, it has no effect
         } else {
           println("Sold for the price of: ");
           println(price);
           Message argm = Sold(this,g);
           winningAgent ! message(argm);
           this.goals = without(this.goals, g); // will add again if not sold?
           // TODO: inform organizer (list of winners and list of unhappy)
         }}
       }
       Nothing => { println("What?"); }
     }
   }
   
  Unit run() {
    println("AA: Auctioneer started.");
    //while(this.goals != EmptySet) {
      // in Haskell: mapM(goal_rule, this.goals);
      // in plain ABS
      List<Route> iGoals = this.goals;
      List<Fut<Unit>> goalFutures = Nil;
      Int i = length(iGoals) - 1;
      while (i >= 0) {
       Route nA = nth(iGoals, i);
       Fut<Unit> f = this ! goal_rule(nA);
       goalFutures = Cons(f,goalFutures);
       i=i-1;
      }
      println("Auctioneer finished the goals!");
      i = 0;
      while (i< length(goalFutures)) {
        Fut<Unit> f= nth(goalFutures, i);
        await f?;
        i = i + 1;
      }
    //}
  }
}

{
	println("M: begin");
	Destination duisburg  = ADestination("Duisburg", 4, 4000);
	Destination munich  = ADestination("Munich", 16, 16000);
	List<Train> trains  = Nil;
	List<Container> containers = Nil;
	Int noTrains = 10;
	Int noContainers = 1000;
	
	while(noTrains>0){
		Int startTime  = random(3);
		Rat riskFactor  = random();
		Rat budget = 100000 * random() + 1000;
		Int endTime = startTime + 4;
		Train tr = ATrain(30, startTime, endTime, budget, riskFactor);
		appendright(trains, tr);	
		noTrains = noTrains -1;
	}
	
	println("M:Init Trains complete");
	
	while(noContainers>0){
	    Destination dest = if random(10) > 7 then duisburg else munich;
	    Rat startTime  = if random(10) > 7 then 1 else 3;
		Rat riskFactor  = random();
		Rat budget = 1000 * random() + 100;
		if(dest == munich)
			budget = budget*4;
		Rat latest = case dest {
							ADestination(_,y,_) =>
								startTime + 4 + y;
						};
		Container c = AContainer(dest, startTime, latest, budget, riskFactor);
		appendright(containers, c);	
		noContainers = noContainers - 1;
	}  
	
	AuctionOrganizer pr = new AuctionOrganizerAgent(trains, containers);
	//pr!init();
	pr!start(1);
	println("M: end");


}
