module ABS.StdLib;
export *;




// TODO: uncomment these as soon as we fix the bug that causes name collisions
// between ExceptionDecl and DataConstructor.  (This only affects StdLib.)
// See TypeCheckerHelper:checkForDuplicateDecls().

// exception DivisionByZeroException;
// exception AssertionFailException;
// exception PatternMatchFailException;
// exception NullPointerException;
// exception StackOverflowEcxeption;
// exception HeapOverflowException;
// exception KeyboardInterruptException;

def Bool and(Bool a, Bool b) = a && b;
def Bool not(Bool a) = ~a;

//def A max<A>(A a, A b) = if a > b then a else b;
//def A min<A>(A a, A b) = if a < b then a else b;
    
def Rat abs(Rat x) = if x > 0 then x else -x;

def Int pow(Int b, Int n) =
    if n < 0 then
        0
    else case n {
        0 => 1;
        _ => b * pow(b, n-1);
    };

/**
 * Returns a random number between 0 (inclusive) and below (exclusive).
 */
//def Int random(Int below) = builtin;

/**
 * Truncates a towards zero.
 */
//def Int truncate(Rat a) = builtin;


data Maybe<A> = Nothing | Just(A fromJust);

def Bool isJust<A>(Maybe<A> a) = 
    case a { Just(j) => True; Nothing => False; };

data Either<A, B> = Left(A left) | Right(B right);

def Bool isLeft<A,B>(Either<A, B> value) = 
    case value { Left(x) => True; _ => False; };
    
def Bool isRight<A,B>(Either<A, B> value) = ~isLeft(value);


data Pair<A, B> = APair(A fst, B snd); 

data Triple<A, B, C> = ATriple(A fstT, B sndT, C trd); 

// Sets

// Sets are currently implemented as sorted lists (any implementation
// must yield the same structure regardless of insertion order so that
// set equality via == is preserved).  Using the Insert_ constructor
// directly is strongly discouraged.
data Set<A> = EmptySet | Insert(A, Set<A>);

// set constructor helper
/*def Set<A> set<A>(List<A> l) = 
    case l { 
       Nil => EmptySet; 
       Cons(x,xs) => insertElement(set(xs), x); 
    };
*/
/**
 * Returns True if set 'ss' contains element 'e', False otherwise.
 */
/*def Bool contains<A>(Set<A> ss, A e) =
  case ss {
    EmptySet => False ;
    Insert(e, _) => True;
    Insert(x, xs) => if x > e then False else contains(xs, e);
  };
  */
/**
 * Returns True if set 'xs' is empty, False  otherwise.
 */
//def Bool emptySet<A>(Set<A> xs) = (xs == EmptySet); 

/**
 * Returns the size of set 'xs'.
 */
/*def Int size<A>(Set<A> xs) = 
   case xs {
      EmptySet => 0 ; 
      Insert(s, ss) => 1 + size(ss); 
   };
*/
/**
 * Returns the union of sets 'set1' and 'set2'.
 */
/*def Set<A> union<A>(Set<A> set1, Set<A> set2) =
   case set1 {
      EmptySet => set2;
      Insert(e1, ss1) =>  case set2 {
          EmptySet => set1;
          Insert(e1, ss2) => Insert(e1, union(ss1, ss2));
          Insert(e2, ss2) =>
            if e1 < e2
            then Insert(e1, union(ss1, set2))
            else Insert(e2, union(set1, ss2));
      };
   }; 
*/
/**
 * Returns the intersection of sets 'set1' and 'set2'.
 */
/*def Set<A> intersection<A>(Set<A> set1, Set<A> set2) =
   case set1 {
      EmptySet => EmptySet;
      Insert(e1, ss1) =>  case set2 {
          EmptySet => EmptySet;
          Insert(e1, ss2) => Insert(e1, intersection(ss1, ss2));
          Insert(e2, ss2) =>
            if e1 < e2
            then intersection(ss1, set2)
            else intersection(set1, ss2);
      };
   };
*/
/**
 * Returns the difference of sets 'set1' and 'set2', i.e., all
 * elements of 'set1' that are not in 'set2'.
 */
/*def Set<A> difference<A>(Set<A> set1, Set<A> set2) =
   case set1 {
      EmptySet => EmptySet;
      Insert(e1, ss1) =>  case set2 {
          EmptySet => set1;
          Insert(e1, ss2) => difference(ss1, ss2);
          Insert(e2, ss2) =>
            if e1 < e2
            then Insert(e1, difference(ss1, set2))
            else difference(set1, ss2);
      };
   };
*/
/**
 * Returns a set with all elements of set 'xs' plus element 'e'.
 * Returns 'xs' if 'xs' already contains 'e'.
 */
/*def Set<A> insertElement<A>(Set<A> xs, A e) =
  case xs {
      EmptySet => Insert(e, EmptySet);
      Insert(e, _) => xs;
      Insert(x, ss) => if e < x then Insert(e, xs) else Insert(x, insertElement(ss, e));
  };
*/
/**
 * Returns a set with all elements of set 'xs' except element 'e'.
 */
/*def Set<A> remove<A>(Set<A> xs, A e) = 
  case xs {
     EmptySet => EmptySet ;
     Insert(e, ss) => ss;
     Insert(x, ss) => if e < x then xs else Insert(x, remove(ss, e));
  };
*/
/**
 * Returns one (arbitrary) element from a set.
 * To iterate over a set, take one element and remove it from the set.
 * Repeat until set is empty.
 */
/*def A take<A>(Set<A> ss) =
  case ss {
    Insert(e, _) => e;
  };
*/
// checks whether the input set has more elements to be iterated.
//def Bool hasNext<A>(Set<A> s) = ~ emptySet(s); 

// Partial function to iterate over a set.
/*def Pair<Set<A>,A> next<A>(Set<A> s) = 
   case s { 
      Insert(e, set2) => APair(set2,e); 
   };
*/
// Lists
data List<A> = Nil | Cons(A head, List<A> tail);

def List<A> list<A>(List<A> l) = l; // list constructor helper

/**
 * Returns the length of list 'list'.
 */
def Int length<A>(List<A> list) = 
   case list { 
      Nil => 0 ; 
      Cons(p, l) => 1 + length(l) ; 
   };

/**
 * Returns True if list 'list' is empty, False otherwise.
 */
def Bool isEmpty<A>(List<A> list) = list == Nil;

/**
 * Returns element 'n' of list 'list'.
 */
def A nth<A>(List<A> list, Int n) = 
  case n { 
    0 => head(list) ; 
    _ => nth(tail(list), n-1); 
  };
  
/**
 * Returns a list where all occurrences of a have been removed
 */
def List<A> without<A>(List<A> list, A a) =
  case list {
     Nil => Nil;
     Cons(a, tail) => without(tail,a);
     Cons(x, tail) => Cons(x, without(tail,a));
  };  
  
/**
 * Returns a list containing all elements of list 'list1'
 * followed by all elements of list 'list2'.
 */
def List<A> concatenate<A>(List<A> list1, List<A> list2) =
  case list1 { 
    Nil => list2 ; 
    Cons(head, tail) =>  Cons(head, concatenate(tail, list2)); 
  };
  
/**
 * Returns a list containing all elements of list 'list' followed by 'p'.
 */
def List<A> appendright<A>(List<A> list, A p) = 
    concatenate(list, Cons(p, Nil));

/**
 * Returns a list containing all elements of 'list' in reverse order.
 */
def List<A> reverse<A>(List<A> list) =
  case list { 
     Cons(hd, tl) => appendright(reverse(tl), hd); 
     Nil => Nil; 
  };
  
/**
 * Returns a list of length 'n' containing 'p' n times.
 */
def List<A> copy<A>(A p, Int n) = 
   case n { 0 => Nil; m => Cons(p,copy(p,m-1)); };




// Maps
data Map<A, B> = EmptyMap | InsertAssoc(Pair<A, B>, Map<A, B>);
 // map constructor helper (does not preserve injectivity)
def Map<A, B> map<A, B>(List<Pair<A, B>> l) =
  case l { 
     Nil => EmptyMap; 
     Cons(hd, tl) => InsertAssoc(hd, map(tl)); 
  };
  
  
def Map<A, B> removeKey<A, B>(Map<A, B> map, A key) = // remove from the map
  case map {
  	EmptyMap => map;
    InsertAssoc(APair(key, _), m) => m;
    InsertAssoc(pair, tail) => InsertAssoc(pair, removeKey(tail, key));
  };
    

def List<B> values<A, B>(Map<A, B> map) =
  case map {
    EmptyMap => Nil ;
    InsertAssoc(APair(_, elem), tail) => Cons(elem, values(tail)) ;
  };

/**
 * Returns a set containing all keys of map 'map'.
 */
/*def Set<A> keys<A, B>(Map<A, B> map) =
  case map { 
    EmptyMap => EmptySet ;
    InsertAssoc(APair(a, _), tail) => insertElement(keys(tail), a); 
  };
  */  
/**
 * Returns the value associated with key 'k' in map 'ms', or 'Nothing'.
 */
def Maybe<B> lookup<A, B>(Map<A, B> ms, A k) = // retrieve from the map
  case ms {
     InsertAssoc(APair(k, y), _) => Just(y);
     InsertAssoc(_, tm) => lookup(tm, k);
     EmptyMap => Nothing;
  };

/**
 * Compatibility stub for #342. DEPRECATED!
 */
def Maybe<B> lookupMaybe<A, B>(Map<A, B> ms, A k) = lookup(ms, k);

/**
 * Returns the value associated with key 'k' in map 'ms',
 * or fails if not present.
 */
def B lookupUnsafe<A, B>(Map<A, B> ms, A k) = // retrieve from the map
  fromJust(lookup(ms,k));
  
/**
 * Returns the value associated with key 'k' in map 'ms', or the value 'd'
 * if 'k' has no entry in 'ms'.
 */
def B lookupDefault<A, B>(Map<A, B> ms, A k, B d) = // retrieve from the map
  case ms {
     InsertAssoc(APair(k, y), _) => y;
     InsertAssoc(_, tm) => lookupDefault(tm, k, d);
     EmptyMap => d;
  };

/**
 * Returns a map with all entries of 'map' plus an entry 'p',
 * which might override but not remove another entry with the same key.
 */
def Map<A, B> insert<A, B>(Map<A, B> map, Pair<A, B> p) = InsertAssoc(p, map);

/**
 * Returns a map with all entries of 'ms' plus an entry mapping 'k' to 'v',
 * minus the first entry already mapping 'k' to a value.
 */  
def Map<A, B> put<A, B>(Map<A, B> ms, A k, B v) =
  case ms {
    EmptyMap => InsertAssoc(APair(k, v),EmptyMap);
    InsertAssoc(APair(k, _), ts) => InsertAssoc(APair(k, v), ts);
    InsertAssoc(p, ts) => InsertAssoc(p, put(ts, k, v));
  };

/**
 * Returns a string with the base-10 textual representation of 'n'.
 */
//def String intToString(Int n) =
//  case n < 0 {
//    True => "-" + intToStringPos(-n);
//    False => intToStringPos(n);
//  };

//def String intToStringPos(Int n) = builtin;

/**
 * Returns a substring of string str of the given length starting from start (inclusive)
 * Where the first character has index 0
 * 
 * Example:
 *    substr("abcde",1,3) => "bcd"
 *     
 */
//def String substr(String str, Int start, Int length) = builtin;

/**
 * Returns the length of the given string
 */
//def Int strlen(String str) = builtin;

/**
 * Returns a string representation for t.
 */
//def String toString<T>(T t) = builtin;





